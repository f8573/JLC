package net.faulj.svd;

import net.faulj.matrix.Matrix;

/**
 * Utilities for estimating the numerical rank of a matrix.
 * <p>
 * The rank of a matrix is the dimension of the vector space generated by its columns.
 * In numerical linear algebra, this is determined by counting the number of singular
 * values strictly greater than a specific tolerance.
 * </p>
 *
 * <h2>Numerical Rank Definition:</h2>
 * <p>
 * The rank <i>r</i> is the number of singular values σ<sub>i</sub> such that:
 * </p>
 * <pre>
 * σ<sub>i</sub> > ε
 * </pre>
 * <p>
 * Where ε is a tolerance threshold accounting for floating-point errors.
 * </p>
 *
 * <h2>Tolerance Selection:</h2>
 * <ul>
 * <li><b>Default Tolerance:</b> ε = max(m, n) * ||A||₂ * machine_epsilon</li>
 * <li><b>Custom Tolerance:</b> Users can specify a custom threshold for noise filtering</li>
 * </ul>
 *
 * <h2>Usage Example:</h2>
 * <pre>{@code
 * Matrix A = ...; // Singular matrix
 * double[] singularValues = new SVDecomposition().decompose(A).getSingularValues();
 *
 * // Estimate rank
 * int rank = RankEstimation.effectiveRank(singularValues);
 *
 * // Check for full rank
 * boolean isFullRank = (rank == Math.min(A.getRowCount(), A.getColumnCount()));
 * }</pre>
 *
 * <h2>Applications:</h2>
 * <ul>
 * <li>Detecting singular or ill-conditioned matrices</li>
 * <li>Determining the dimension of the null space (Nullity = n - Rank)</li>
 * <li>Subspace intersection and basis construction</li>
 * </ul>
 *
 * @author JLC Development Team
 * @version 1.0
 * @since 1.0
 * @see SVDecomposition
 * @see net.faulj.condition.ConditionNumber
 */
public class RankEstimation {
	private static final double EPS = 2.220446049250313e-16;

	/**
	 * Create a rank estimation helper.
	 */
	public RankEstimation() {
	}

	/**
	 * Estimates the numerical rank using the default tolerance based on the singular values length.
	 *
	 * @param singularValues singular values in descending order
	 * @return numerical rank
	 */
	public static int effectiveRank(double[] singularValues) {
		if (singularValues == null) {
			throw new IllegalArgumentException("Singular values must not be null");
		}
		double tol = defaultTolerance(singularValues, singularValues.length, singularValues.length);
		return effectiveRank(singularValues, tol);
	}

	/**
	 * Estimates the numerical rank using the default tolerance based on matrix dimensions.
	 *
	 * @param singularValues singular values in descending order
	 * @param rows number of rows in the original matrix
	 * @param cols number of columns in the original matrix
	 * @return numerical rank
	 */
	public static int effectiveRank(double[] singularValues, int rows, int cols) {
		if (singularValues == null) {
			throw new IllegalArgumentException("Singular values must not be null");
		}
		double tol = defaultTolerance(singularValues, rows, cols);
		return effectiveRank(singularValues, tol);
	}

	/**
	 * Estimates the numerical rank using a user-provided tolerance.
	 *
	 * @param singularValues singular values in descending order
	 * @param tolerance threshold for counting singular values as non-zero
	 * @return numerical rank
	 */
	public static int effectiveRank(double[] singularValues, double tolerance) {
		if (singularValues == null) {
			throw new IllegalArgumentException("Singular values must not be null");
		}
		if (tolerance < 0) {
			throw new IllegalArgumentException("Tolerance must be non-negative");
		}
		int rank = 0;
		for (double s : singularValues) {
			if (Math.abs(s) > tolerance) {
				rank++;
			}
		}
		return rank;
	}

	/**
	 * Estimates the numerical rank of a matrix by computing its singular values.
	 *
	 * @param A matrix to analyze
	 * @return numerical rank
	 */
	public static int effectiveRank(Matrix A) {
		if (A == null) {
			throw new IllegalArgumentException("Matrix must not be null");
		}
		if (!A.isReal()) {
			throw new UnsupportedOperationException("Rank estimation via SVD requires a real-valued matrix");
		}
		double[] singularValues = new SVDecomposition().decompose(A).getSingularValues();
		double tol = defaultTolerance(singularValues, A.getRowCount(), A.getColumnCount());
		return effectiveRank(singularValues, tol);
	}

	/**
	 * Computes the default tolerance for numerical rank decisions.
	 *
	 * @param singularValues singular values in descending order
	 * @param rows number of rows in the original matrix
	 * @param cols number of columns in the original matrix
	 * @return tolerance value
	 */
	public static double defaultTolerance(double[] singularValues, int rows, int cols) {
		if (singularValues == null) {
			throw new IllegalArgumentException("Singular values must not be null");
		}
		double maxSigma = 0.0;
		for (double s : singularValues) {
			maxSigma = Math.max(maxSigma, Math.abs(s));
		}
		if (maxSigma == 0.0) {
			return 0.0;
		}
		return Math.max(rows, cols) * maxSigma * EPS;
	}
}
